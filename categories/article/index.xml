<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Article on なるはやで いい感じの 動作確認</title>
    <link>//kamichidu.github.com/categories/article/</link>
    <description>Recent content in Article on なるはやで いい感じの 動作確認</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Tue, 20 Sep 2016 00:00:00 +0900</lastBuildDate>
    <atom:link href="//kamichidu.github.com/categories/article/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ブラウザ上でのJavaScriptエラーを収集する手法について</title>
      <link>//kamichidu.github.com/post/2016/09/20-collecting-error-log-on-the-browser/</link>
      <pubDate>Tue, 20 Sep 2016 00:00:00 +0900</pubDate>
      
      <guid>//kamichidu.github.com/post/2016/09/20-collecting-error-log-on-the-browser/</guid>
      <description>

&lt;p&gt;現代的なWebサービスを構築する場合、避けては通れないのが各種ログの収集と活用です。
HTTPサーバの各種ログ (e.g. アクセスログ、エラーログ) を始めとして、サーバサイドのアプリケーションログなどもよく収集されています。
サーバサイドのログについては、fluentdなど、収集するための手法はある程度確立しているように思いますが、フロントエンドでのログ収集については、あまり議論されていないように思います。&lt;/p&gt;

&lt;p&gt;先日、お仕事でWebサービスを作成したのですが、そのときに改めてブラウザ上でのエラーログの収集について本気出して考えてみたので、ここに記事としてまとめてみようと思います。&lt;/p&gt;

&lt;h1 id=&#34;ブラウザ上のエラーログ収集の目的&#34;&gt;ブラウザ上のエラーログ収集の目的&lt;/h1&gt;

&lt;p&gt;まず収集する目的についてですが、大きなところで以下のようになるかと思います。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;継続的な不具合修正のため (サービス改善)&lt;/li&gt;
&lt;li&gt;ユーザからの問い合わせ時に調査するため (サポート改善)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;特に強調したいのは、サポートの改善という側面です。
Webサービスを継続的に運用していく場合、どうしてもサポートに時間を割かざるを得ません。&lt;/p&gt;

&lt;p&gt;サポート対象外のブラウザでサービスを利用された場合でも、『動かない』という問い合わせを受ける可能性は大いにあります。
このようなケースでは、以下のフローで問い合わせ対応を行うでしょう。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ユーザからの問い合わせを受ける&lt;/li&gt;
&lt;li&gt;サポートから利用ブラウザとバージョンについて、ユーザに質問する&lt;/li&gt;
&lt;li&gt;ユーザからの回答を得、サポート対象外である旨を伝える&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;しかし、ユーザのITリテラシによっては、利用しているブラウザとバージョンをサポートが知るために、あれこれと受け答えしなければならないことも多くあります。
この手間が、そのままサポートのための費用に直結し、さらにはエンジニアを疲弊させることにも繋がります。&lt;/p&gt;

&lt;p&gt;他にも、本ケースにおいては、サポート対象のブラウザを利用しているにも関わらず、不具合が発生している可能性もあります。
この場合、再現性のあるものであれば良いですが、必ずしもそうとも限りません。
もしそのときのエラーログがあれば、かなり調査の助けになるのではないでしょうか。
他、IEの互換モードを利用していたために発生した不具合だとか、考えるとキリがありません。&lt;/p&gt;

&lt;p&gt;結果的に、可能な限り多くのブラウザ環境において、可能な限り確実にログを収集したいという欲求が生まれます。
これが収集の目的となります。&lt;/p&gt;

&lt;h1 id=&#34;手法&#34;&gt;手法&lt;/h1&gt;

&lt;p&gt;ここでは、色々考えた中から、なるべく目的に沿う形で2つの手法について考察します。
どちらの場合でも、サーバサイドではログを受け付けるREST APIのエンドポイントが存在する前提とします。&lt;/p&gt;

&lt;h2 id=&#34;xmlhttprequestを用いる手法&#34;&gt;XMLHttpRequestを用いる手法&lt;/h2&gt;

&lt;p&gt;Ajaxで有名なXMLHttpRequestを利用する方法です。
モダンブラウザにおいては、XMLHttpRequestの仕様は共通化されてきているため、比較的多くのブラウザで簡単に利用することが可能です。
RESTful APIのお作法に準じるような、HTTP POSTによってエンドポイントにログを投げつけることができます。&lt;/p&gt;

&lt;h3 id=&#34;利点&#34;&gt;利点&lt;/h3&gt;

&lt;p&gt;他のREST APIを呼ぶときと同様の実装をすることができ、全体として統一感を持たせられます。&lt;/p&gt;

&lt;h3 id=&#34;欠点&#34;&gt;欠点&lt;/h3&gt;

&lt;p&gt;ブラウザごとの実装差異をどうにかする必要があります。
また、古めのブラウザではまともに動作しません。&lt;/p&gt;

&lt;h2 id=&#34;imgタグを用いる手法&#34;&gt;IMGタグを用いる手法&lt;/h2&gt;

&lt;p&gt;昔から存在するIMGタグのsrc属性を利用する方法です。
私は今回、この方法が一番ベターだと判断しました。
IE5互換モードでも安定して動作したため、ほとんどのブラウザで動くのではないでしょうか。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;new Image().src= loggingEndpoint + &#39;?&#39; + encodeURIComponent(message);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;利点-1&#34;&gt;利点&lt;/h3&gt;

&lt;p&gt;かなり広範なブラウザで安定して動作します。
また、実装もかなり単純です。&lt;/p&gt;

&lt;h3 id=&#34;欠点-1&#34;&gt;欠点&lt;/h3&gt;

&lt;p&gt;ブラウザによって、URLの長さに制約があることが欠点として挙げられます。
またHTTP GETでログを投げることになるため、キャッシュ切りをする必要があるかもしれません。&lt;/p&gt;

&lt;h1 id=&#34;実環境への適用&#34;&gt;実環境への適用&lt;/h1&gt;

&lt;p&gt;実際にログを投げつける方法にどれを選んだとしても、JavaScript上でエラーが発生したことを補足しなければ、永遠にログを収集することはできません。
エラーを捕捉するための基本的な戦略としては、 &lt;code&gt;window.onerror&lt;/code&gt; や &lt;code&gt;window.addEventListener&lt;/code&gt; を用いるようにします。
JavaScriptはどうしてもページ単位でグローバルな領域であれこれする必要があるため、エラーイベントのハンドリングにも気を遣う必要が出てきます。&lt;/p&gt;

&lt;p&gt;比較的最近のブラウザであれば、 &lt;code&gt;window.addEventListener(&#39;error&#39;, function(evt){})&lt;/code&gt; によって特に考慮なくエラーを捕捉することができます。
しかし古めのブラウザになると、 &lt;code&gt;window.addEventListener&lt;/code&gt; は実装されていないため、 &lt;code&gt;window.onerror&lt;/code&gt; を利用する必要がありますが、これが結構曲者です。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;window.onerror&lt;/code&gt; は、ただ1つの関数しか持つことができず、意図せず上書きしてしまうとアプリケーションコードを破壊してしまいます。
そのため、以下のフローにより上書きを行います。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;window.onerror&lt;/code&gt; に関数が登録されているかをチェック&lt;/li&gt;
&lt;li&gt;登録されていれば変数に退避させる&lt;/li&gt;
&lt;li&gt;&lt;code&gt;window.onerror&lt;/code&gt; に関数を登録する&lt;/li&gt;
&lt;li&gt;退避させた関数を、今回登録した関数内で呼ぶ&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体的には、以下のような実装となるはずです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var myErrorHandler= function(message, url, ex){ /* ... */ };
if(window.addEventListener)
{
    window.addEventListener(&#39;error&#39;, function(evt){
        myErrorHandler.call(this, evt.message, evt.filename, evt);
    }, false);
}
else
{
    var next= window.onerror || function(){};
    window.onerror= function(){
        myErrorHandler.apply(this, arguments);
        next.apply(this, arguments);
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;JavaScriptのエラーログを収集する目的について述べ、実現するための2通りの手法について比較しました。
改めて考えると、本記事の文脈においてはXMLHttpRequestを使う意義は薄いを言わざるを得ず、IMGタグによる収集しかないかな、と思います。&lt;/p&gt;

&lt;p&gt;実際、ブラウザのエラーログを収集して損はないと思うので、今後Webサービスを作るのであれば必ず実装したほうが良いと思います。
ログを収集しておけば、サポート対応時にアクセス時刻さえ聞けば問題の切り分けが大分捗ると思うので、開発時に多少手間でも実装したほうが後が楽です。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>高速なVim Plug-inについての一考察</title>
      <link>//kamichidu.github.com/post/2015/12/06-vim-speed-consideration/</link>
      <pubDate>Sun, 06 Dec 2015 00:00:00 +0900</pubDate>
      
      <guid>//kamichidu.github.com/post/2015/12/06-vim-speed-consideration/</guid>
      <description>

&lt;p&gt;この記事はVim Advent Calendar 2015の6日目の記事です。
前日は&lt;a href=&#34;http://qiita.com/daisuzu&#34;&gt;daisuzu&lt;/a&gt;さんによる&lt;a href=&#34;http://daisuzu.hatenablog.com/entry/2015/12/05/002129&#34;&gt;VimのCTRL-X補完について&lt;/a&gt;でした。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;さて、この記事ではVimにおけるVim Plug-inについての速度というものをテーマに、あれこれ考察を述べたいと思います。
一般的なソフトウェアの速度についての話から、Vim Plug-inにおける速度は何か、を掘り下げて考えてみることを目的にします。
また話を単純にするため、UnixにおけるCUI Vimの話のみします。&lt;/p&gt;

&lt;p&gt;※記載や認識が間違っている箇所がありましたら教えていただけると喜びます。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;一般的なソフトウェアにおける速度について&#34;&gt;一般的なソフトウェアにおける速度について&lt;/h2&gt;

&lt;p&gt;一般的にソフトウェアにおける速度とは、スループットとレイテンシ、応答時間とで語られることが多いと思います。&lt;/p&gt;

&lt;p&gt;スループットは、単位時間あたりにソフトウェアが処理可能なデータ量を指します。
具体的な意味については&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%82%B9%E3%83%AB%E3%83%BC%E3%83%97%E3%83%83%E3%83%88&#34;&gt;Wikipedia:スループット&lt;/a&gt;を参照していただくことにします。&lt;/p&gt;

&lt;p&gt;レイテンシは、ユーザの入力時点からソフトウェアが応答を返し、実際にユーザへと表示されるまでの時間を指します。
こちらも具体的な意味については&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%AC%E3%82%A4%E3%83%86%E3%83%B3%E3%82%B7&#34;&gt;Wikipedia:レイテンシ&lt;/a&gt;を参照してください。&lt;/p&gt;

&lt;p&gt;応答時間は、ユーザの入力時点からソフトウェアが応答を返し始めるまでの時間を指します。
こちらも具体的な意味については&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E5%BF%9C%E7%AD%94%E6%99%82%E9%96%93&#34;&gt;Wikipedia:応答時間&lt;/a&gt;を参照してください。&lt;/p&gt;

&lt;h2 id=&#34;vim-plug-inにおける速度とは&#34;&gt;Vim Plug-inにおける速度とは&lt;/h2&gt;

&lt;p&gt;ここでVim Plug-inにおける速度について考えていきます。
Vimはテキストエディタであり、使用する目的はテキストを編集することだと信じています。
また、Vimの目的から言えば、Vim Plug-inの目的とはテキストの編集を補助することだと言えるかもしれません。
きっと。多分。 I HOPE SO.&lt;/p&gt;

&lt;p&gt;テキストを編集するという行為においての速度を気にする場面として、大きく以下のパターンに分けられるのではないでしょうか。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Vimを起動するとき&lt;/li&gt;
&lt;li&gt;編集作業を行っているとき&lt;/li&gt;
&lt;li&gt;マクロ等でテキストを一括処理しているとき&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以下、各パターンそれぞれについて、速度とは何かを考えてみます。&lt;/p&gt;

&lt;h3 id=&#34;vimを起動するとき&#34;&gt;Vimを起動するとき&lt;/h3&gt;

&lt;p&gt;我々は今端末にいます。
「さあ、編集を始めよう&amp;hellip;！」と思い立ち、または必要にかられ、我々は端末に &lt;code&gt;vim path/to/file&lt;/code&gt; と打ち込み、華麗にReturnをえぐります。&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;さくっと起動しなかったら、嫌ですよね？
Vimの起動時における速度とは、単純にReturnをえぐり込んでからVimの画面が表示され、編集を開始できる状態になるまでの時間と考えることができそうです。
つまり、一般的な議論における応答速度にあたると言えそうです。&lt;/p&gt;

&lt;h3 id=&#34;編集作業を行っているとき&#34;&gt;編集作業を行っているとき&lt;/h3&gt;

&lt;p&gt;我々は今Vimでの編集を行っています。
ふと天啓が降りてきて、唐突に &lt;code&gt;public static final String RENBAN_KAISHI= 0;&lt;/code&gt; とテキストを打ち込もうとします。&lt;/p&gt;

&lt;p&gt;p &amp;hellip; u &amp;hellip; b &amp;hellip; l &amp;hellip; c &amp;hellip;&lt;/p&gt;

&lt;p&gt;1文字打ち込むごとに、ラグがあったら嫌ですよね？
編集作業を行っている際の速度とは、1文字打ち込んでから次の文字を打ち込めるようになるまでの時間と考えることができそうです。
また、文字が打ち込めても画面に反映されていない状態だとどうにもならないので、文字を打ち込み、画面に反映され、次の文字が打ち込めるようになるまで、と考えて問題ないかと思います。
つまり、一般的な議論におけるレイテンシにあたると言えそうです。&lt;/p&gt;

&lt;h3 id=&#34;マクロ等でテキストを一括処理しているとき&#34;&gt;マクロ等でテキストを一括処理しているとき&lt;/h3&gt;

&lt;p&gt;我々は今、巨大なファイルに対して定型処理を行う必要に迫られています。
一度きりしか使わないけどスクリプトを書いて処理するか、それとも血の滲むような努力を前提として手動で行うか&amp;hellip;&lt;/p&gt;

&lt;p&gt;「そうだ、マクロ使えばいいじゃん」&lt;/p&gt;

&lt;p&gt;「そうだ、Vim scriptでやっちゃおう」&lt;/p&gt;

&lt;p&gt;天啓を得た我々は、早速取りかかります。
マクロができたので、早速実行をします。&lt;/p&gt;

&lt;p&gt;&amp;hellip;&amp;hellip;&amp;hellip;. (10分後) &amp;hellip; 「いつ終わるのか」&lt;/p&gt;

&lt;p&gt;Vim scriptができたので、早速実行をします。&lt;/p&gt;

&lt;p&gt;&amp;hellip;&amp;hellip;&amp;hellip;. (10分後) &amp;hellip; 「いつ終わるのか」&lt;/p&gt;

&lt;p&gt;時間がかかるなら待ちますが、あまり長い時間は待ちたくないですよね？
古の夜間コンパイルなど2015年の今になっては、ぞっとしない話です。
テキストを一括処理する際の速度とは、単純に処理開始から処理終了までの時間と考えることができそうです。
もちろん、ユーザの体感速度を向上させるために非同期で処理するや進捗を表示するといった工夫はできますが、こと速度の議論においては意味を持ちません。
つまり、一般的な議論におけるスループットにあたると言えそうです。&lt;/p&gt;

&lt;h2 id=&#34;高速なvim-plug-inとは&#34;&gt;高速なVim Plug-inとは&lt;/h2&gt;

&lt;p&gt;ここまででVim Plug-inにおける速度とは何か、ということを考えてきました。
結果的に、速度と一口に言っても、その文脈に応じて意味あいや目的とすることが変わってくることがわかってきました。
つまり単に「高速な」Vim Plug-inと言ったときに、その意味するところは大きく違ってきそうです。
高速なVim Plug-inについて考えるときは、そのVim Plug-inがどういった目的のものなのかをよく考える必要がありそうです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/thinca/vim-quickrun&#34;&gt;thinca/vim-quickrun&lt;/a&gt;を例に速度を考察してみます。
vim-quickrunの目的と、目的に応じた速度とは、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;編集中のバッファをカジュアルに実行し、結果を別バッファに表示する&lt;/p&gt;

&lt;p&gt;実行を開始してから、別バッファが開くまたは結果がなるべく早く表示されることが重要かと思います。
これは応答速度の概念が適当かと思います。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;編集を中断させない&lt;/p&gt;

&lt;p&gt;バックグラウンドで動いているプロセスから出力を受け取ってバッファへと書き出す必要性から、定期的にポーリングを行っています。
ポーリング処理を行っている際はどうしてもVimをブロックせざるを得ないため、レイテンシの概念が適当かと思います。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;となります。
(間違ってたらゴメンナサイ。)
つまり「vim-quickrunを高速にしたい！」と考えた場合、応答速度を求めるのかレイテンシを求めるのかを切り分けた上でアプローチをする必要があります。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;ここまでで、Vim Plug-inにおける速度とは何か、というテーマで真面目に考えてみました。
Vim Plug-inにおける速度とは、Vim Plug-inの目的によって様々な視点で考えられること、Vim Plug-inの目的に応じた適当なアプローチをすることが重要であることがわかりました。
スループット、レイテンシ、応答時間のいずれが重要なのかを適当に見極め、適当なアプローチを実施することによって世界は高速なVim Plug-inで溢れることを期待してやみません。&lt;/p&gt;

&lt;h2 id=&#34;付録&#34;&gt;付録&lt;/h2&gt;

&lt;p&gt;ここまでで速度について抽象的な話をしてきましたが、じゃあ実際にどうするのっていう方法論について書いてみます。
あくまでも参考程度に考えていただき、今まで話をしてきたように目的に応じて都度都度適当なアプローチや方法論を探る必要があることは意識してください。&lt;/p&gt;

&lt;h3 id=&#34;応答時間を向上させるには&#34;&gt;応答時間を向上させるには&lt;/h3&gt;

&lt;p&gt;応答時間を向上させるためには、大きく以下のアプローチがあるかと思います。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;そもそも処理をしない&lt;/p&gt;

&lt;p&gt;アルゴリズムの見直しにより処理をなくす、ないし減らすことで応答時間は向上します。
また、キャッシングの導入によっても向上はしますが、キャッシングのメリット/デメリットやその効果を見極めて慎重に導入する必要があります。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;処理を遅延させ、必要になった段階で実行する&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Shougo/neobundle.vim&#34;&gt;Shougo/neobundle.vim&lt;/a&gt;ではLazy Loadingとして実装されているものです。
みなさま馴染みがあるのではないでしょうか。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;処理を非同期で行い、必要になった段階で該当処理が終了しているか判定し、終了していなければ待つ&lt;/p&gt;

&lt;p&gt;実装が面倒ですが、場合によっては効果があります。
例えばVim起動時に非同期で外部プロセスを走らせておき、特定のFileTypeに変更されたときに外部プロセスの終了を待つなどができます。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;スループットを向上させるには&#34;&gt;スループットを向上させるには&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;そもそも処理をしない&lt;/li&gt;
&lt;li&gt;キャッシングの導入&lt;/li&gt;
&lt;li&gt;処理を非同期で行い、複数の処理を並列で処理する&lt;/li&gt;
&lt;li&gt;実行速度の速い言語で実装する&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;レイテンシを向上させるには&#34;&gt;レイテンシを向上させるには&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;がんばる (力尽きた)(復活したら何か書くかもしれない)&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>